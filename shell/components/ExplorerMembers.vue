<script>
import { MANAGEMENT, NORMAN, VIRTUAL_TYPES } from '@shell/config/types';
import ResourceTable from '@shell/components/ResourceTable';
import Masthead from '@shell/components/ResourceList/Masthead';
import { AGE, ROLE, STATE, PRINCIPAL } from '@shell/config/table-headers';
import { canEditClusterPermissions, canViewClusterPermissions } from '@shell/components/form/Members/ClusterPermissionsEditor.vue';
import { canEditProjectPermissions, canViewProjectPermissions } from '@shell/components/form/Members/ProjectMembershipEditor.vue';
import Banner from '@components/Banner/Banner.vue';
import Tabbed from '@shell/components/Tabbed/index.vue';
import Tab from '@shell/components/Tabbed/Tab.vue';
import SortableTable from '@shell/components/SortableTable';
import { mapGetters } from 'vuex';
import { allHash } from '@shell/utils/promise';
import { camelCase } from 'lodash';

/**
 * Explorer members page.
 * Route: /c/local/explorer/members
 */
export default {
  name: 'ExplorerMembers',

  components: {
    Banner,
    Masthead,
    ResourceTable,
    Tabbed,
    Tab,
    SortableTable
  },

  props: {
    // Cluster tole template binding create route - defaults to the explorer route
    createLocationOverride: {
      type:    Object,
      default: () => {
        return {
          name:   'c-cluster-product-resource-create',
          params: { resource: MANAGEMENT.CLUSTER_ROLE_TEMPLATE_BINDING }
        };
      }
    }
  },

  async fetch() {
    if (canViewClusterPermissions(this.$store)) {
      const clusterId = this.$store.getters['currentCluster'].id;
      const normanClusterRTBSchema = this.$store.getters[
        `rancher/schemaFor`
      ](NORMAN.CLUSTER_ROLE_TEMPLATE_BINDING);

      this.$set(this, 'normanClusterRTBSchema', normanClusterRTBSchema);

      if (normanClusterRTBSchema) {
        Promise.all([
          this.$store.dispatch(`rancher/findAll`, { type: NORMAN.CLUSTER_ROLE_TEMPLATE_BINDING, opt: { filter: { clusterId } } }, { root: true }),
          this.$store.dispatch(`management/findAll`, { type: MANAGEMENT.CLUSTER_ROLE_TEMPLATE_BINDING })
        ]).then(([normanBindings]) => {
          this.$set(this, 'normanClusterRoleTemplateBindings', normanBindings);
          this.loadingClusterBindings = false;
        });
      } else {
        this.loadingClusterBindings = false;
      }
    }

    if (canViewProjectPermissions(this.$store)) {
      const normanProjectRTBSchema = this.$store.getters['rancher/schemaFor'](NORMAN.PROJECT_ROLE_TEMPLATE_BINDING);

      this.$set(this, 'normanProjectRTBSchema', normanProjectRTBSchema);

      if (normanProjectRTBSchema) {
        this.$store.dispatch('rancher/findAll', { type: NORMAN.PROJECT_ROLE_TEMPLATE_BINDING }, { root: true })
          .then((bindings) => {
            this.$set(this, 'projectRoleTemplateBindings', bindings);
            this.loadingProjectBindings = false;
          });
      } else {
        this.loadingProjectBindings = false;
      }
    }

    this.$store.dispatch('management/findAll', { type: MANAGEMENT.PROJECT })
      .then(projects => this.$set(this, 'projects', projects));

    const hydration = {
      normanPrincipals:  this.$store.dispatch('rancher/findAll', { type: NORMAN.PRINCIPAL }),
      mgmt:              this.$store.dispatch(`management/findAll`, { type: MANAGEMENT.USER }),
      mgmtRoleTemplates: this.$store.dispatch(`management/findAll`, { type: MANAGEMENT.ROLE_TEMPLATE }),
    };

    await allHash(hydration);
  },

  data() {
    return {
      schema: this.$store.getters[`management/schemaFor`](
        MANAGEMENT.CLUSTER_ROLE_TEMPLATE_BINDING
      ),
      headers:        [STATE, PRINCIPAL, ROLE, AGE],
      createLocation: {
        ...this.createLocationOverride,
        params: {
          ...this.createLocationOverride.params,
          cluster: this.$store.getters['currentCluster'].id
        }
      },
      currentUsersProjectPermissions:    {},
      resource:                          MANAGEMENT.CLUSTER_ROLE_TEMPLATE_BINDING,
      normanClusterRTBSchema:            null,
      normanProjectRTBSchema:            null,
      normanClusterRoleTemplateBindings: [],
      projectRoleTemplateBindings:       [],
      projects:                          [],
      VIRTUAL_TYPES,
      projectRoleTemplateColumns:        [
        STATE,
        {
          name:      'member',
          labeKey:   'generic.name',
          value:     'principalId',
          formatter: 'Principal'
        },
        {
          name:     'role',
          labelKey: 'tableHeaders.role',
          value:    'roleTemplate.nameDisplay'
        },
      ],
      loadingProjectBindings: true,
      loadingClusterBindings: true,
      userCanManageProject:   {}
    };
  },

  computed: {
    ...mapGetters(['currentCluster']),
    clusterRoleTemplateBindings() {
      // Switch norman cluster role template binding to steve cluster role template binding (not sure why?)
      return this.normanClusterRoleTemplateBindings.map(b => b.clusterroletemplatebinding) ;
    },
    filteredClusterRoleTemplateBindings() {
      return this.clusterRoleTemplateBindings.filter(
        b => b?.clusterName === this.$store.getters['currentCluster'].id
      );
    },
    filteredProjects() {
      return this.projects.reduce((all, p) => {
        if (p?.spec?.clusterName === this.currentCluster.id) {
          all[p.id] = p;
        }

        return all;
      }, {});
    },
    filteredProjectRoleTemplateBindings() {
      const out = this.projectRoleTemplateBindings.filter((rb) => {
        const projectId = rb.projectId.replace(':', '/');

        return !!this.filteredProjects[projectId];
      });

      return out;
    },
    projectsWithoutRoles() {
      const inUse = this.filteredProjectRoleTemplateBindings.reduce((projects, binding) => {
        const thisProjectId = (binding.projectId || '').replace(':', '/');

        if (!projects.includes(thisProjectId)) {
          projects.push(thisProjectId);
        }

        return projects;
      }, []);

      return Object.keys(this.filteredProjects).reduce((all, projectId) => {
        const project = this.filteredProjects[projectId];

        if ( !inUse.includes(projectId)) {
          all.push(project);
        }

        return all;
      }, []);
    },

    // We're using this because we need to show projects as groups even if the project doesn't have any role bindings
    rowsWithFakeProjects() {
      const fakeRows = this.projectsWithoutRoles.map((project) => {
        return {
          groupByLabel:     `${ ('resourceTable.groupLabel.notInAProject') }-${ project.id }`,
          isFake:           true,
          mainRowKey:       project.id,
          nameDisplay:      project.spec?.displayName, // Enable filtering by the project name
          project,
          availableActions: [],
          projectId:        project.id
        };
      });

      // We need to group each of the TemplateRoleBindings by the user + project
      const userRoles = [...fakeRows, ...this.filteredProjectRoleTemplateBindings].reduce((rows, curr) => {
        const {
          userId, groupPrincipalId, roleTemplate, projectId
        } = curr;

        const userOrGroup = userId || groupPrincipalId;

        if (!userOrGroup) {
          return rows;
        }

        const userOrGroupKey = userOrGroup + projectId;

        if (!rows[userOrGroupKey] ) {
          rows[userOrGroupKey] = curr;
          rows[userOrGroupKey].allRoles = [];
        }

        if (roleTemplate) {
          rows[userOrGroupKey].allRoles.push(curr.roleTemplate);
        }

        const { allRoles = [], isCurrentUser } = curr;

        // Determine if the current user can manage permissions for this specific project
        // We can skip this if..
        // - user can manage cluster, that trumps everything else
        // - not current user, we only use this for showing permissions of that user
        // We're assigning userCanManageProject in a getter for performance reasons
        if (!this.userCanManageCluster && isCurrentUser) {
          this.userCanManageProject[projectId] = allRoles.some((rtb) => {
            const { id, rules } = rtb;

            return id === 'project-owner' || rules.some((rule) => {
              const { apiGroups = [], resources = [], verbs = [] } = rule;

              return ['*', 'management.cattle.io'].some(apiGroup => apiGroups.includes(apiGroup)) &&
                ['*', 'projectroletemplatebindings'].some(resource => resources.includes(resource)) &&
                ['*', 'own', 'create'].some(verb => verbs.includes(verb));
            });
          });
        }

        return rows;
      }, {});

      return Object.values(userRoles);
    },
    userCanManageCluster() {
      // There can be a LOT of cluster and project bindings and a LOT of churn for them over sockets
      // So once we have the required information to determine this... do it and only once.
      // This means we won't update buttons if the user gains/loses cluster rights, but avoids looping through a large list often
      if (
        typeof this._userCanManageCluster === 'undefined' &&
        this.$store.getters['management/all'](MANAGEMENT.USER)?.length &&
        this.filteredClusterRoleTemplateBindings.length
      ) {
        this._userCanManageCluster = this.filteredClusterRoleTemplateBindings.some(crtb => (crtb.user?.isCurrentUser || crtb.isCurrentUser) && crtb.roleTemplateName === 'cluster-owner');
      }

      return this._userCanManageCluster;
    },
    canViewClusterMemberPermissions() {
      return canViewClusterPermissions(this.$store);
    },
    canViewProjectMemberPermissions() {
      return canViewProjectPermissions(this.$store);
    },
    mastHeadTString() {
      const strings = [];

      if (this.canViewClusterMemberPermissions) {
        strings.push('cluster');
      }
      if (this.canViewProjectMemberPermissions) {
        strings.push('project');
      }
      const tString = camelCase(strings.join(' and '));

      return `members.${ tString }`;
    },
    canManageClusterMembers() {
      return canEditClusterPermissions(this.$store);
    },
    canManageProjectMembers() {
      return canEditProjectPermissions(this.$store);
    },
    isLocal() {
      return this.$store.getters['currentCluster'].isLocal;
    }
  },
  methods: {
    getMgmtProjectId(group) {
      return group.group.key.replace(':', '/');
    },
    getMgmtProject(group) {
      return this.$store.getters['management/byId'](MANAGEMENT.PROJECT, this.getMgmtProjectId(group));
    },
    getProjectLabel(group) {
      return this.getMgmtProject(group)?.spec?.displayName;
    },
    getManageProjectMembersPermission(projectId) {
      return this.userCanManageCluster || this.userCanManageProject[projectId];
    },
    addProjectMember(group) {
      this.$store.dispatch('cluster/promptModal', {
        component:      'AddProjectMemberDialog',
        componentProps: {
          projectId:   group.group.key.replace('/', ':'),
          saveInModal: true
        },
        modalSticky: true
      });
    },

    getProjectRoleBinding(row, role) {
      // Each row is a combination of project, role and user/group
      // So find the specfic roleBindingTemplate corresponding to the specific project, role + user/group
      const userOrGroupKey = row.userId ? 'userId' : 'groupPrincipalId';

      return this.projectRoleTemplateBindings.find((r) => {
        return r.projectId === row.projectId && r.roleTemplateId === role.id && r[userOrGroupKey] === row[userOrGroupKey];
      });
    },

    async removeRole(row, role, event) {
      const resource = this.getProjectRoleBinding(row, role);

      await resource.promptRemove();
    },

    viewRoleInAPI(row, role) {
      const resource = this.getProjectRoleBinding(row, role);

      if (resource?.canViewInApi) {
        resource.viewInApi();
      }
    },
    slotName(project) {
      return `main-row:${ project.id }`;
    },
  }
};
</script>

<template>
  <div class="project-members">
    <Masthead
      :schema="schema"
      :resource="resource"
      :favorite-resource="VIRTUAL_TYPES.CLUSTER_MEMBERS"
      :create-location="createLocation"
      :create-button-label="t('members.createActionLabel')"
      :is-creatable="false"
      :type-display="t(mastHeadTString)"
    />
    <Banner
      v-if="isLocal"
      color="error"
      :label="t('members.localClusterWarning')"
    />
    <Tabbed>
      <Tab
        v-if="canViewClusterMemberPermissions"
        name="cluster-membership"
        :label="t('members.clusterMemebership')"
      >
        <div
          v-if="canManageClusterMembers"
          class="row mb-10 cluster-add"
        >
          <n-link
            :to="createLocation"
            class="btn role-primary pull-right"
          >
            {{ t('members.createActionLabel') }}
          </n-link>
        </div>
        <ResourceTable
          :schema="schema"
          :headers="headers"
          :rows="filteredClusterRoleTemplateBindings"
          :groupable="true"
          :show-grouping="true"
          :namespaced="false"
          :loading="$fetchState.pending || !currentCluster || loadingClusterBindings"
          sub-search="subSearch"
          :sub-fields="['nameDisplay']"
        />
      </Tab>
      <Tab
        v-if="canViewProjectMemberPermissions"
        name="project-membership"
        :label="t('members.projectMembership')"
      >
        <SortableTable
          group-by="projectId"
          :loading="$fetchState.pending || !currentCluster || loadingProjectBindings"
          :rows="rowsWithFakeProjects"
          :headers="projectRoleTemplateColumns"
          :table-actions="false"
          :row-actions="false"
        >
          <template #group-by="group">
            <div class="group-bar">
              <div
                v-trim-whitespace
                class="group-tab"
              >
                <div
                  v-clean-html="getProjectLabel(group)"
                  class="project-name"
                />
              </div>
              <div class="right">
                <button
                  v-if="getManageProjectMembersPermission(group.group.key)"
                  type="button"
                  class="create-namespace btn btn-sm role-secondary mr-10 right"
                  @click="addProjectMember(group)"
                >
                  {{ t('members.createActionLabel') }}
                </button>
              </div>
            </div>
          </template>
          <template
            #cell:role="{row}"
          >
            <span
              v-for="(role, j) in row.allRoles"
              :key="j"

              ref="value"
              :data-testid="`role-value-${j}`"
              class="role"
            >
              <span
                class="role-value"
                :class="{'text-link-enabled' : row.canViewInApi}"
                @click="viewRoleInAPI(row, role)"
              >
                {{ role.nameDisplay }}
              </span>
              <i
                v-if="getManageProjectMembersPermission(row.projectId)"
                class="icon icon-close"
                :data-testid="`role-values-close-${j}`"
                @click="removeRole(row, role, $event)"
              />
            </span>
          </template>
          <template
            v-for="project in projectsWithoutRoles"
            v-slot:[slotName(project)]
          >
            <tr
              :key="project.id"
              class="main-row"
            >
              <td
                class="empty text-center"
                colspan="100%"
              >
                {{ t('members.noRolesAssigned') }}
              </td>
            </tr>
          </template>
        </SortableTable>
      </Tab>
    </Tabbed>
  </div>
</template>

<style lang='scss' scoped>

.role {
  align-items: center;
    background-color: rgba(0, 0, 0, 0.05);
    border: 1px solid var(--header-border);
    border-radius: 5px;
    color: var(--tag-text);
    line-height: 20px;
    padding: 2px 5px;
    white-space: nowrap;
    display: inline-flex;
    margin-right: 3px;
}

.role-value {
  &.text-link-enabled {
    cursor: pointer;
    &:hover {
      color: var(--primary);
    }
  }
  + .icon-close {
    margin-left: 3px;
    cursor: pointer;
    &:hover {
      color: var(--primary);
    }
  }
}

.project-members {
  & ::v-deep .group-bar{
    display: flex;
    justify-content: space-between;
  }
}
.cluster-add {
  justify-content: flex-end;
}
</style>
