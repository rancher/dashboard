# Notification Center

The Notification Center allows users to view various notifications.

Currently, this is notifications generated by the UI, but in the future we may want to include notifications from other sources, such as backend CRDs.

Notifications will be persisted in Local Storage, so if the user changes browser, they will lose their notifications - this is fine for starters.

Notifications and growls are related - going forward, from an API point of view, users should only use the notifications API and we would deprecate the growl API.

Growls will only be shown for Success, Warning and Error notifications.

Currently, we support linking a notification to a user preference, so for notifications like the new release notification, when the user marks the notification as read, we can update the corresponding preference so that in the future we will not add a new notification for this purpose. We may want to extend this in the future to be able to update backend resources upon reading of a notification, when/if we add support for notifications from the backend.

Notifications has been implemented via a new store - we would hide this beneath an API that would fit with the new extensions API work, so that users use that API rather than accessing the store.
 
## Accessibility

The Notification Center has been implemented with the RcDropdown component - there are some accessibility issues we need to figure out:

- A notification can contain two actions - a primary and secondary button. These are optional. All notifications initially have a button that allows the user to mark the notification as read, if it is unread.

In addition to the list of notifications, there can be a 'Mark all as read' action in a header at the top of the notification center.

How I believe it should work:

- You open the notification center, if you press the down arrow, you would focus in the 'Mark all as read', if it is shown, otherwise you focus on the first notification.
- You press down or up, you cycle through the notifications and the 'Mark all as read' at the top.
- If you press enter or space on a notification, that notification receives focus IF is has the 'mark read' or any actions in it.
- Once a notification is focused, focus is trapped - tab cycles through the buttons in the notification.
- Pressing ESCape, exists the focus trap and allows the user to up/down through the notifications and the 'Mark all as read' link

Also, the RcDropdown does not have a max height and we can have a lot of notifications, so the drop down will need to support scrolling - ideally allowing the header at the top to be sticky.

## Operation Notifications

Todo, but suggestion:

Let's say a user starts to provision a cluster, which adds an in-progress notification. We need a mechanism to allow something to watch this in-progress operation and update the notification as it progresses and even add another notification when it completes/fails. We also need to make sure that if the user refreshes their web browser, we can pick up any in-progress operations and monitor them again until completion/failure.

Note, we can't rely on web sockets for this, as the user may start an operation in a cluster, such as a Helm install and then go to Fleet or another area of the UI, at which point we are no longer connected to the cluster relevant to the operation.

Suggestion would be that we define a simple function for monitoring progress of a given operation and have that as an extension point, so we can register these.

When we add an in-progress notification, we can supply the name of the progress monitor extension and some additional data - we store this on the notification.

Periodically, the notification center will loop through all of the in-progress notifications that have a progress monitor and let them perform action(s) to determine the progress - this could be an API call to fetch latest state.

In the future, we might want to off-load this to a web-worker, but this would complicate things slightly, as the progress monitors would need to be bundled up separately somehow so that they can be loaded into the web-worker.

